<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · Krylov.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Krylov.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Krylov.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">API</a></li><li class="is-active"><a class="tocitem" href>Solvers</a><ul class="internal"><li><a class="tocitem" href="#Krylov-methods"><span>Krylov methods</span></a></li></ul></li><li><a class="tocitem" href="../gpu/">GPU</a></li><li><a class="tocitem" href="../matrix-free/">Matrix-free operators</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/master/docs/src/solvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>Detailed examples may be found <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/tree/master/examples">here</a>.</p><h2 id="Krylov-methods"><a class="docs-heading-anchor" href="#Krylov-methods">Krylov methods</a><a id="Krylov-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Krylov-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Krylov.cg" href="#Krylov.cg"><code>Krylov.cg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cg(A, b; M, atol, rtol, itmax, radius, linesearch, verbose)</code></pre><p>The conjugate gradient method to solve the symmetric linear system Ax=b.</p><p>The method does <em>not</em> abort if A is not definite.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite. M also indicates the weighted norm in which residuals are measured.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/cg.jl#L14-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cr" href="#Krylov.cr"><code>Krylov.cr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cr(A, b; M, atol, rtol, γ, itmax, radius, verbose, linesearch)</code></pre><p>A truncated version of Stiefel’s Conjugate Residual method to solve the symmetric linear system Ax=b. The matrix A must be positive semi-definite.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite. M also indicates the weighted norm in which residuals are measured.</p><p>In a linesearch context, &#39;linesearch&#39; must be set to &#39;true&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/cr.jl#L10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.symmlq" href="#Krylov.symmlq"><code>Krylov.symmlq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = symmlq(A, b; M, λ, transfer_to_cg, λest, atol, rtol, etol, window, itmax, conlim, verbose)</code></pre><p>Solve the shifted linear system</p><pre><code class="language-none">(A + λ I) x = b</code></pre><p>using the SYMMLQ method, where λ is a shift parameter, and A is square and symmetric.</p><p>SYMMLQ produces monotonic errors ‖x*-x‖₂.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/symmlq.jl#L15-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cg_lanczos" href="#Krylov.cg_lanczos"><code>Krylov.cg_lanczos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cg_lanczos(A, b; M, atol, rtol, itmax, check_curvature, verbose)</code></pre><p>The Lanczos version of the conjugate gradient method to solve the symmetric linear system</p><pre><code class="language-none">Ax = b</code></pre><p>The method does <em>not</em> abort if A is not definite.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/cg_lanczos.jl#L15-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cg_lanczos_shift_seq" href="#Krylov.cg_lanczos_shift_seq"><code>Krylov.cg_lanczos_shift_seq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cg_lanczos_shift_seq(A, b, shifts; M, atol, rtol, itmax, check_curvature, verbose)</code></pre><p>The Lanczos version of the conjugate gradient method to solve a family of shifted systems</p><pre><code class="language-none">(A + αI) x = b  (α = α₁, ..., αₙ)</code></pre><p>The method does <em>not</em> abort if A + αI is not definite.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/cg_lanczos.jl#L127-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.minres" href="#Krylov.minres"><code>Krylov.minres</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = minres(A, b; M, λ, atol, rtol, etol, window, itmax, conlim, verbose)</code></pre><p>Solve the shifted linear least-squares problem</p><pre><code class="language-none">minimize ‖b - (A + λ I)x‖₂²</code></pre><p>or the shifted linear system</p><pre><code class="language-none">(A + λ I) x = b</code></pre><p>using the MINRES method, where λ ≥ 0 is a shift parameter, where A is square and symmetric.</p><p>MINRES is formally equivalent to applying CR to Ax=b when A is positive definite, but is typically more stable and also applies to the case where A is indefinite.</p><p>MINRES produces monotonic residuals ‖r‖₂ and optimality residuals ‖Aᵀr‖₂.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/minres.jl#L25-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.minres_qlp" href="#Krylov.minres_qlp"><code>Krylov.minres_qlp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = minrres_qlp(A, b; M, atol, rtol, λ, itmax, verbose)</code></pre><p>MINRES-QLP is the only method based on the Lanczos process that returns the minimum-norm solution on singular inconsistent systems (A + λI)x = b, where λ is a shift parameter. It is significantly more complex but can be more reliable than MINRES when A is ill-conditioned.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite. M also indicates the weighted norm in which residuals are measured.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/minres_qlp.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.diom" href="#Krylov.diom"><code>Krylov.diom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = diom(A, b; M, N, atol, rtol, itmax, memory, pivoting, verbose)</code></pre><p>Solve the consistent linear system Ax = b using direct incomplete orthogonalization method.</p><p>DIOM is similar to CG with partial reorthogonalization.</p><p>An advantage of DIOM is that nonsymmetric or symmetric indefinite or both nonsymmetric and indefinite systems of linear equations can be handled by this single algorithm.</p><p>This implementation allows a left preconditioner M and a right preconditioner N.</p><ul><li>Left  preconditioning : M⁻¹Ax = M⁻¹b</li><li>Right preconditioning : AN⁻¹u = b with x = N⁻¹u</li><li>Split preconditioning : M⁻¹AN⁻¹u = M⁻¹b with x = N⁻¹u</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/diom.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.dqgmres" href="#Krylov.dqgmres"><code>Krylov.dqgmres</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = dqgmres(A, b; M, N, atol, rtol, itmax, memory, verbose)</code></pre><p>Solve the consistent linear system Ax = b using DQGMRES method.</p><p>DQGMRES algorithm is based on the incomplete Arnoldi orthogonalization process and computes a sequence of approximate solutions with the quasi-minimal residual property.</p><p>This implementation allows a left preconditioner M and a right preconditioner N.</p><ul><li>Left  preconditioning : M⁻¹Ax = M⁻¹b</li><li>Right preconditioning : AN⁻¹u = b with x = N⁻¹u</li><li>Split preconditioning : M⁻¹AN⁻¹u = M⁻¹b with x = N⁻¹u</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/dqgmres.jl#L16-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.usymlq" href="#Krylov.usymlq"><code>Krylov.usymlq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = usymlq(A, b, c; atol, rtol, transfer_to_usymcg, itmax, verbose)</code></pre><p>Solve the linear system Ax = b using the USYMLQ method.</p><p>USYMLQ is based on a tridiagonalization process for unsymmetric matrices. The error norm ‖x - x*‖ monotonously decreases in USYMLQ. It&#39;s considered as a generalization of SYMMLQ.</p><p>It can also be applied to under-determined and over-determined problems. In all cases, problems must be consistent.</p><p>An option gives the possibility of transferring to the USYMCG point, when it exists. The transfer is based on the residual norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/usymlq.jl#L22-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.usymqr" href="#Krylov.usymqr"><code>Krylov.usymqr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = usymqr(A, b, c; atol, rtol, itmax, verbose)</code></pre><p>Solve the linear system Ax = b using the USYMQR method.</p><p>USYMQR is based on a tridiagonalization process for unsymmetric matrices. The residual norm ‖b - Ax‖ monotonously decreases in USYMQR. It&#39;s considered as a generalization of MINRES.</p><p>It can also be applied to under-determined and over-determined problems. USYMQR finds the minimum-norm solution if problems are inconsistent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/usymqr.jl#L22-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.tricg" href="#Krylov.tricg"><code>Krylov.tricg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, y, stats) = tricg(A, b, c; M, N, atol, rtol, spd, snd, flip, τ, ν, itmax, verbose)</code></pre><p>TriCG solves the symmetric linear system</p><pre><code class="language-none">[ τE    A ] [ x ] = [ b ]
[  Aᵀ  νF ] [ y ]   [ c ],</code></pre><p>where τ and ν are real numbers, E = M⁻¹ ≻ 0 and F = N⁻¹ ≻ 0. TriCG could breakdown if <code>τ = 0</code> or <code>ν = 0</code>. It&#39;s recommended to use TriMR in these cases.</p><p>By default, TriCG solves symmetric and quasi-definite linear systems with τ = 1 and ν = -1. If <code>flip = true</code>, TriCG solves another known variant of SQD systems where τ = -1 and ν = 1. If <code>spd = true</code>, τ = ν = 1 and the associated symmetric and positive definite linear system is solved. If <code>snd = true</code>, τ = ν = -1 and the associated symmetric and negative definite linear system is solved. <code>τ</code> and <code>ν</code> are also keyword arguments that can be directly modified for more specific problems.</p><p>TriCG is based on the preconditioned orthogonal tridiagonalization process and its relation with the preconditioned block-Lanczos process.</p><pre><code class="language-none">[ M   O ]
[ 0   N ]</code></pre><p>indicates the weighted norm in which residuals are measured. It&#39;s the Euclidean norm when <code>M</code> and <code>N</code> are identity operators.</p><p>TriCG stops when <code>itmax</code> iterations are reached or when <code>‖rₖ‖ ≤ atol + ‖r₀‖ * rtol</code>. <code>atol</code> is an absolute tolerance and <code>rtol</code> is a relative tolerance.</p><p>Additional details can be displayed if the <code>verbose</code> mode is enabled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/tricg.jl#L14-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.trimr" href="#Krylov.trimr"><code>Krylov.trimr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, y, stats) = trimr(A, b, c; M, N, atol, rtol, spd, snd, flip, sp, τ, ν, itmax, verbose)</code></pre><p>TriMR solves the symmetric linear system</p><pre><code class="language-none">[ τE    A ] [ x ] = [ b ]
[  Aᵀ  νF ] [ y ]   [ c ],</code></pre><p>where τ and ν are real numbers, E = M⁻¹ ≻ 0 and F = N⁻¹ ≻ 0. TriMR handles saddle-point systems (<code>τ = 0</code> or <code>ν = 0</code>) and adjoint systems (<code>τ = 0</code> and <code>ν = 0</code>) without any risk of breakdown.</p><p>By default, TriMR solves symmetric and quasi-definite linear systems with τ = 1 and ν = -1. If <code>flip = true</code>, TriMR solves another known variant of SQD systems where τ = -1 and ν = 1. If <code>spd = true</code>, τ = ν = 1 and the associated symmetric and positive definite linear system is solved. If <code>snd = true</code>, τ = ν = -1 and the associated symmetric and negative definite linear system is solved. If <code>sp = true</code>, τ = 1, ν = 0 and the associated saddle-point linear system is solved. <code>τ</code> and <code>ν</code> are also keyword arguments that can be directly modified for more specific problems.</p><p>TriMR is based on the preconditioned orthogonal tridiagonalization process and its relation with the preconditioned block-Lanczos process.</p><pre><code class="language-none">[ M   O ]
[ 0   N ]</code></pre><p>indicates the weighted norm in which residuals are measured. It&#39;s the Euclidean norm when <code>M</code> and <code>N</code> are identity operators.</p><p>TriMR stops when <code>itmax</code> iterations are reached or when <code>‖rₖ‖ ≤ atol + ‖r₀‖ * rtol</code>. <code>atol</code> is an absolute tolerance and <code>rtol</code> is a relative tolerance.</p><p>Additional details can be displayed if the <code>verbose</code> mode is enabled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/trimr.jl#L14-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.trilqr" href="#Krylov.trilqr"><code>Krylov.trilqr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, t, stats) = trilqr(A, b, c; atol, rtol, transfer_to_usymcg, itmax, verbose)</code></pre><p>Combine USYMLQ and USYMQR to solve adjoint systems.</p><pre><code class="language-none">[0  A] [t] = [b]
[Aᵀ 0] [x]   [c]</code></pre><p>USYMLQ is used for solving primal system <code>Ax = b</code>. USYMQR is used for solving dual system <code>Aᵀt = c</code>.</p><p>An option gives the possibility of transferring from the USYMLQ point to the USYMCG point, when it exists. The transfer is based on the residual norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/trilqr.jl#L15-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.bilq" href="#Krylov.bilq"><code>Krylov.bilq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = bilq(A, b; c, atol, rtol, transfer_to_bicg, itmax, verbose)</code></pre><p>Solve the square linear system Ax = b using the BiLQ method.</p><p>BiLQ is based on the Lanczos biorthogonalization process. When A is symmetric and b = c, BiLQ is equivalent to SYMMLQ.</p><p>An option gives the possibility of transferring to the BiCG point, when it exists. The transfer is based on the residual norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/bilq.jl#L15-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cgs" href="#Krylov.cgs"><code>Krylov.cgs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cgs(A, b; M, atol, rtol, itmax, verbose)</code></pre><p>Solve the consistent linear system Ax = b using conjugate gradient squared algorithm.</p><p>From &quot;Iterative Methods for Sparse Linear Systems (Y. Saad)&quot; :</p><p>«The method is based on a polynomial variant of the conjugate gradients algorithm. Although related to the so-called bi-conjugate gradients (BCG) algorithm, it does not involve adjoint matrix-vector multiplications, and the expected convergence rate is about twice that of the BCG algorithm.</p><p>The Conjugate Gradient Squared algorithm works quite well in many cases. However, one difficulty is that, since the polynomials are squared, rounding errors tend to be more damaging than in the standard BCG algorithm. In particular, very high variations of the residual vectors often cause the residual norms computed to become inaccurate.</p><p>TFQMR and BICGSTAB were developed to remedy this difficulty.»</p><p>This implementation allows a right preconditioner M.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/cgs.jl#L16-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.qmr" href="#Krylov.qmr"><code>Krylov.qmr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = qmr(A, b; c, atol, rtol, itmax, verbose)</code></pre><p>Solve the square linear system Ax = b using the QMR method.</p><p>QMR is based on the Lanczos biorthogonalization process. When A is symmetric and b = c, QMR is equivalent to MINRES.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/qmr.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.bilqr" href="#Krylov.bilqr"><code>Krylov.bilqr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, t, stats) = bilqr(A, b, c; atol, rtol, transfer_to_bicg, itmax, verbose)</code></pre><p>Combine BiLQ and QMR to solve adjoint systems.</p><pre><code class="language-none">[0  A] [t] = [b]
[Aᵀ 0] [x]   [c]</code></pre><p>BiLQ is used for solving primal system <code>Ax = b</code>. QMR is used for solving dual system <code>Aᵀt = c</code>.</p><p>An option gives the possibility of transferring from the BiLQ point to the BiCG point, when it exists. The transfer is based on the residual norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/bilqr.jl#L15-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cgls" href="#Krylov.cgls"><code>Krylov.cgls</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cgls(A, b; M, λ, atol, rtol, radius, itmax, verbose)</code></pre><p>Solve the regularized linear least-squares problem</p><pre><code class="language-none">minimize ‖b - Ax‖₂² + λ ‖x‖₂²</code></pre><p>using the Conjugate Gradient (CG) method, where λ ≥ 0 is a regularization parameter. This method is equivalent to applying CG to the normal equations</p><pre><code class="language-none">(AᵀA + λI) x = Aᵀb</code></pre><p>but is more stable.</p><p>CGLS produces monotonic residuals ‖r‖₂ but not optimality residuals ‖Aᵀr‖₂. It is formally equivalent to LSQR, though can be slightly less accurate, but simpler to implement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/cgls.jl#L25-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.crls" href="#Krylov.crls"><code>Krylov.crls</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = crls(A, b; M, λ, atol, rtol, radius, itmax, verbose)</code></pre><p>Solve the linear least-squares problem</p><pre><code class="language-none">minimize ‖b - Ax‖₂² + λ ‖x‖₂²</code></pre><p>using the Conjugate Residuals (CR) method. This method is equivalent to applying MINRES to the normal equations</p><pre><code class="language-none">(AᵀA + λI) x = Aᵀb.</code></pre><p>This implementation recurs the residual r := b - Ax.</p><p>CRLS produces monotonic residuals ‖r‖₂ and optimality residuals ‖Aᵀr‖₂. It is formally equivalent to LSMR, though can be substantially less accurate, but simpler to implement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/crls.jl#L24-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cgne" href="#Krylov.cgne"><code>Krylov.cgne</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cgne(A, b; M, λ, atol, rtol, itmax, verbose)</code></pre><p>Solve the consistent linear system</p><pre><code class="language-none">Ax + √λs = b</code></pre><p>using the Conjugate Gradient (CG) method, where λ ≥ 0 is a regularization parameter. This method is equivalent to applying CG to the normal equations of the second kind</p><pre><code class="language-none">(AAᵀ + λI) y = b</code></pre><p>but is more stable. When λ = 0, this method solves the minimum-norm problem</p><p>min ‖x‖₂  s.t. Ax = b.</p><p>When λ &gt; 0, it solves the problem</p><pre><code class="language-none">min ‖(x,s)‖₂  s.t. Ax + √λs = b.</code></pre><p>CGNE produces monotonic errors ‖x-x*‖₂ but not residuals ‖r‖₂. It is formally equivalent to CRAIG, though can be slightly less accurate, but simpler to implement. Only the x-part of the solution is returned.</p><p>A preconditioner M may be provided in the form of a linear operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/cgne.jl#L32-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.crmr" href="#Krylov.crmr"><code>Krylov.crmr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = crmr(A, b; M, λ, atol, rtol, itmax, verbose)</code></pre><p>Solve the consistent linear system</p><pre><code class="language-none">Ax + √λs = b</code></pre><p>using the Conjugate Residual (CR) method, where λ ≥ 0 is a regularization parameter. This method is equivalent to applying CR to the normal equations of the second kind</p><pre><code class="language-none">(AAᵀ + λI) y = b</code></pre><p>but is more stable. When λ = 0, this method solves the minimum-norm problem</p><pre><code class="language-none">min ‖x‖₂  s.t.  x ∈ argmin ‖Ax - b‖₂.</code></pre><p>When λ &gt; 0, this method solves the problem</p><pre><code class="language-none">min ‖(x,s)‖₂  s.t. Ax + √λs = b.</code></pre><p>CGMR produces monotonic residuals ‖r‖₂. It is formally equivalent to CRAIG-MR, though can be slightly less accurate, but simpler to implement. Only the x-part of the solution is returned.</p><p>A preconditioner M may be provided in the form of a linear operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/crmr.jl#L31-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.lslq" href="#Krylov.lslq"><code>Krylov.lslq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x_lq, x_cg, err_lbnds, err_ubnds_lq, err_ubnds_cg, stats) = lslq(A, b; M, N, sqd, λ, atol, btol, etol, window, utol, itmax, σ, conlim, verbose)</code></pre><p>Solve the regularized linear least-squares problem</p><pre><code class="language-none">minimize ‖b - Ax‖₂² + λ² ‖x‖₂²</code></pre><p>using the LSLQ method, where λ ≥ 0 is a regularization parameter. LSLQ is formally equivalent to applying SYMMLQ to the normal equations</p><pre><code class="language-none">(AᵀA + λ² I) x = Aᵀb</code></pre><p>but is more stable.</p><p><strong>Main features</strong></p><ul><li>the solution estimate is updated along orthogonal directions</li><li>the norm of the solution estimate ‖xᴸₖ‖₂ is increasing</li><li>the error ‖eₖ‖₂ := ‖xᴸₖ - x*‖₂ is decreasing</li><li>it is possible to transition cheaply from the LSLQ iterate to the LSQR iterate if there is an advantage (there always is in terms of error)</li><li>if <code>A</code> is rank deficient, identify the minimum least-squares solution</li></ul><p><strong>Input arguments</strong></p><ul><li><code>A::AbstractLinearOperator</code></li><li><code>b::Vector{Float64}</code></li></ul><p><strong>Optional arguments</strong></p><ul><li><p><code>M::AbstractLinearOperator=opEye()</code>: a symmetric and positive definite dual preconditioner</p></li><li><p><code>N::AbstractLinearOperator=opEye()</code>: a symmetric and positive definite primal preconditioner</p></li><li><p><code>sqd::Bool=false</code> indicates whether or not we are solving a symmetric and quasi-definite augmented system If <code>sqd = true</code>, we solve the symmetric and quasi-definite system</p><pre><code class="language-none">[ E    A ] [ r ]   [ b ]
[ Aᵀ  -F ] [ x ] = [ 0 ],</code></pre><p>where E = M⁻¹  and F = N⁻¹.</p><p>If <code>sqd = false</code>, we solve the symmetric and indefinite system</p><pre><code class="language-none">[ E    A ] [ r ]   [ b ]
[ Aᵀ   0 ] [ x ] = [ 0 ].</code></pre><p>In this case, <code>N</code> can still be specified and indicates the norm in which <code>x</code> and the forward error should be measured.</p></li><li><p><code>λ::Float64=0.0</code> is a regularization parameter (see the problem statement above)</p></li><li><p><code>σ::Float64=0.0</code> is an underestimate of the smallest nonzero singular value of <code>A</code>–-setting <code>σ</code> too large will result in an error in the course of the iterations</p></li><li><p><code>atol::Float64=1.0e-8</code> is a stopping tolerance based on the residual</p></li><li><p><code>btol::Float64=1.0e-8</code> is a stopping tolerance used to detect zero-residual problems</p></li><li><p><code>etol::Float64=1.0e-8</code> is a stopping tolerance based on the lower bound on the error</p></li><li><p><code>window::Int=5</code> is the number of iterations used to accumulate a lower bound on the error</p></li><li><p><code>utol::Float64=1.0e-8</code> is a stopping tolerance based on the upper bound on the error</p></li><li><p><code>itmax::Int=0</code> is the maximum number of iterations (0 means no imposed limit)</p></li><li><p><code>conlim::Float64=1.0e+8</code> is the limit on the estimated condition number of <code>A</code> beyond which the solution will be abandoned</p></li><li><p><code>verbose::Bool=false</code> determines verbosity.</p></li></ul><p><strong>Return values</strong></p><p><code>lslq()</code> returns the tuple <code>(x_lq, x_cg, err_lbnds, err_ubnds_lq, err_ubnds_cg, stats)</code> where</p><ul><li><code>x_lq::Vector{Float64}</code> is the LQ solution estimate</li><li><code>x_cg::Vector{Float64}</code> is the CG solution estimate (i.e., the LSQR point)</li><li><code>err_lbnds::Vector{Float64}</code> is a vector of lower bounds on the LQ error–-the vector is empty if <code>window</code> is set to zero</li><li><code>err_ubnds_lq::Vector{Float64}</code> is a vector of upper bounds on the LQ error–-the vector is empty if <code>σ == 0</code> is left at zero</li><li><code>err_ubnds_cg::Vector{Float64}</code> is a vector of upper bounds on the CG error–-the vector is empty if <code>σ == 0</code> is left at zero</li><li><code>stats::SimpleStats</code> collects other statistics on the run.</li></ul><p><strong>Stopping conditions</strong></p><p>The iterations stop as soon as one of the following conditions holds true:</p><ul><li>the optimality residual is sufficiently small (<code>stats.status = &quot;found approximate minimum least-squares solution&quot;</code>) in the sense that either<ul><li>‖Aᵀr‖ / (‖A‖ ‖r‖) ≤ atol, or</li><li>1 + ‖Aᵀr‖ / (‖A‖ ‖r‖) ≤ 1</li></ul></li><li>an approximate zero-residual solution has been found (<code>stats.status = &quot;found approximate zero-residual solution&quot;</code>) in the sense that either<ul><li>‖r‖ / ‖b‖ ≤ btol + atol ‖A‖ * ‖xᴸ‖ / ‖b‖, or</li><li>1 + ‖r‖ / ‖b‖ ≤ 1</li></ul></li><li>the estimated condition number of <code>A</code> is too large in the sense that either<ul><li>1/cond(A) ≤ 1/conlim (<code>stats.status = &quot;condition number exceeds tolerance&quot;</code>), or</li><li>1 + 1/cond(A) ≤ 1 (<code>stats.status = &quot;condition number seems too large for this machine&quot;</code>)</li></ul></li><li>the lower bound on the LQ forward error is less than etol * ‖xᴸ‖</li><li>the upper bound on the CG forward error is less than utol * ‖xᶜ‖</li></ul><p><strong>References</strong></p><ul><li>R. Estrin, D. Orban and M. A. Saunders, <em>Estimates of the 2-Norm Forward Error for SYMMLQ and CG</em>, Cahier du GERAD G-2016-70, GERAD, Montreal, 2016. DOI http://dx.doi.org/10.13140/RG.2.2.19581.77288.</li><li>R. Estrin, D. Orban and M. A. Saunders, <em>LSLQ: An Iterative Method for Linear Least-Squares with an Error Minimization Property</em>, Cahier du GERAD G-2017-xx, GERAD, Montreal, 2017.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/lslq.jl#L7-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.lsqr" href="#Krylov.lsqr"><code>Krylov.lsqr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = lsqr(A, b; M, N, sqd, λ, axtol, btol, atol, rtol, etol, window, itmax, conlim, radius, verbose)</code></pre><p>Solve the regularized linear least-squares problem</p><pre><code class="language-none">minimize ‖b - Ax‖₂² + λ² ‖x‖₂²</code></pre><p>using the LSQR method, where λ ≥ 0 is a regularization parameter. LSQR is formally equivalent to applying CG to the normal equations</p><pre><code class="language-none">(AᵀA + λ² I) x = Aᵀb</code></pre><p>(and therefore to CGLS) but is more stable.</p><p>LSQR produces monotonic residuals ‖r‖₂ but not optimality residuals ‖Aᵀr‖₂. It is formally equivalent to CGLS, though can be slightly more accurate.</p><p>Preconditioners M and N may be provided in the form of linear operators and are assumed to be symmetric and positive definite. If <code>sqd</code> is set to <code>true</code>, we solve the symmetric and quasi-definite system</p><pre><code class="language-none">[ E    A ] [ r ]   [ b ]
[ Aᵀ  -F ] [ x ] = [ 0 ],</code></pre><p>where E = M⁻¹  and F = N⁻¹.</p><p>If <code>sqd</code> is set to <code>false</code> (the default), we solve the symmetric and indefinite system</p><pre><code class="language-none">[ E    A ] [ r ]   [ b ]
[ Aᵀ   0 ] [ x ] = [ 0 ].</code></pre><p>In this case, <code>N</code> can still be specified and indicates the norm in which <code>x</code> should be measured.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/lsqr.jl#L28-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.lsmr" href="#Krylov.lsmr"><code>Krylov.lsmr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = lsmr(A, b; M, N, sqd, λ, axtol, btol, atol, rtol, etol, window, itmax, conlim, radius, verbose)</code></pre><p>Solve the regularized linear least-squares problem</p><pre><code class="language-none">minimize ‖b - Ax‖₂² + λ² ‖x‖₂²</code></pre><p>using the LSMR method, where λ ≥ 0 is a regularization parameter. LSQR is formally equivalent to applying MINRES to the normal equations</p><pre><code class="language-none">(AᵀA + λ² I) x = Aᵀb</code></pre><p>(and therefore to CRLS) but is more stable.</p><p>LSMR produces monotonic residuals ‖r‖₂ and optimality residuals ‖Aᵀr‖₂. It is formally equivalent to CRLS, though can be substantially more accurate.</p><p>Preconditioners M and N may be provided in the form of linear operators and are assumed to be symmetric and positive definite. If <code>sqd</code> is set to <code>true</code>, we solve the symmetric and quasi-definite system</p><pre><code class="language-none">[ E    A ] [ r ]   [ b ]
[ Aᵀ  -F ] [ x ] = [ 0 ],</code></pre><p>where E = M⁻¹  and F = N⁻¹.</p><p>If <code>sqd</code> is set to <code>false</code> (the default), we solve the symmetric and indefinite system</p><pre><code class="language-none">[ E    A ] [ r ]   [ b ]
[ Aᵀ   0 ] [ x ] = [ 0 ].</code></pre><p>In this case, <code>N</code> can still be specified and indicates the norm in which <code>x</code> should be measured.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/lsmr.jl#L28-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.craig" href="#Krylov.craig"><code>Krylov.craig</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, y, stats) = craig(A, b; M, N, sqd, λ, atol, btol, rtol, conlim, itmax, verbose, transfer_to_lsqr)</code></pre><p>Find the least-norm solution of the consistent linear system</p><pre><code class="language-none">Ax + λs = b</code></pre><p>using the Golub-Kahan implementation of Craig&#39;s method, where λ ≥ 0 is a regularization parameter. This method is equivalent to CGNE but is more stable.</p><p>For a system in the form Ax = b, Craig&#39;s method is equivalent to applying CG to AAᵀy = b and recovering x = Aᵀy. Note that y are the Lagrange multipliers of the least-norm problem</p><pre><code class="language-none">minimize ‖x‖  s.t.  Ax = b.</code></pre><p>Preconditioners M⁻¹ and N⁻¹ may be provided in the form of linear operators and are assumed to be symmetric and positive definite. If <code>sqd = true</code>, CRAIG solves the symmetric and quasi-definite system</p><pre><code class="language-none">[ -N   Aᵀ ] [ x ]   [ 0 ]
[  A   M  ] [ y ] = [ b ],</code></pre><p>which is equivalent to applying CG to <code>(AN⁻¹Aᵀ + M)y = b</code> with <code>Nx = Aᵀy</code>.</p><p>If <code>sqd = false</code>, CRAIG solves the symmetric and indefinite system</p><pre><code class="language-none">[ -N   Aᵀ ] [ x ]   [ 0 ]
[  A   0  ] [ y ] = [ b ].</code></pre><p>In this case, M⁻¹ can still be specified and indicates the weighted norm in which residuals are measured.</p><p>In this implementation, both the x and y-parts of the solution are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/craig.jl#L36-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.craigmr" href="#Krylov.craigmr"><code>Krylov.craigmr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, y, stats) = craigmr(A, b; M, N, λ, atol, rtol, itmax, verbose)</code></pre><p>Solve the consistent linear system</p><pre><code class="language-none">Ax + √λs = b</code></pre><p>using the CRAIG-MR method, where λ ≥ 0 is a regularization parameter. This method is equivalent to applying the Conjugate Residuals method to the normal equations of the second kind</p><pre><code class="language-none">(AAᵀ + λI) y = b</code></pre><p>but is more stable. When λ = 0, this method solves the minimum-norm problem</p><pre><code class="language-none">min ‖x‖₂  s.t.  x ∈ argmin ‖Ax - b‖₂.</code></pre><p>When λ &gt; 0, this method solves the problem</p><pre><code class="language-none">min ‖(x,s)‖₂  s.t. Ax + √λs = b.</code></pre><p>Preconditioners M⁻¹ and N⁻¹ may be provided in the form of linear operators and are assumed to be symmetric and positive definite. Afterward CRAIGMR solves the symmetric and quasi-definite system</p><pre><code class="language-none">[ -N   Aᵀ ] [ x ]   [ 0 ]
[  A   M  ] [ y ] = [ b ],</code></pre><p>which is equivalent to applying MINRES to (M + AN⁻¹Aᵀ)y = b.</p><p>CRAIGMR produces monotonic residuals ‖r‖₂. It is formally equivalent to CRMR, though can be slightly more accurate, and intricate to implement. Both the x- and y-parts of the solution are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/eebc92fe95f28f0e2d480656627d204eb699d160/src/craigmr.jl#L31-L65">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API</a><a class="docs-footer-nextpage" href="../gpu/">GPU »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 24 October 2020 14:42">Saturday 24 October 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
