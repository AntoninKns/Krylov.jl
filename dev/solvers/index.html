<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · Krylov.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Krylov.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Krylov.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">API</a></li><li class="is-active"><a class="tocitem" href>Solvers</a><ul class="internal"><li><a class="tocitem" href="#Krylov-methods"><span>Krylov methods</span></a></li></ul></li><li><a class="tocitem" href="../gpu/">GPU</a></li><li><a class="tocitem" href="../matrix-free/">Matrix-free operators</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/master/docs/src/solvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>Detailed examples may be found <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/tree/master/examples">here</a>.</p><h2 id="Krylov-methods"><a class="docs-heading-anchor" href="#Krylov-methods">Krylov methods</a><a id="Krylov-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Krylov-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Krylov.cg" href="#Krylov.cg"><code>Krylov.cg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cg(A, b::AbstractVector{T};
                M=opEye(), atol::T=√eps(T), rtol::T=√eps(T),
                itmax::Int=0, radius::T=zero(T), linesearch::Bool=false,
                verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>The conjugate gradient method to solve the symmetric linear system Ax=b.</p><p>The method does <em>not</em> abort if A is not definite.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite. M also indicates the weighted norm in which residuals are measured.</p><p>If <code>itmax=0</code>, the default number of iterations is set to <code>2 * n</code>, with <code>n = length(b)</code>.</p><p><strong>Reference</strong></p><ul><li>M. R. Hestenes and E. Stiefel, <em>Methods of conjugate gradients for solving linear systems</em>, Journal of Research of the National Bureau of Standards, 49(6), pp. 409–436, 1952.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/cg.jl#L19-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cr" href="#Krylov.cr"><code>Krylov.cr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cr(A, b::AbstractVector{T};
                M=opEye(), atol::T=√eps(T), rtol::T=√eps(T), γ::T=√eps(T), itmax::Int=0,
                radius::T=zero(T), verbose::Int=0, linesearch::Bool=false) where T &lt;: AbstractFloat</code></pre><p>A truncated version of Stiefel’s Conjugate Residual method to solve the symmetric linear system Ax = b or the least-squares problem min ‖b - Ax‖. The matrix A must be positive semi-definite.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite. M also indicates the weighted norm in which residuals are measured.</p><p>In a linesearch context, &#39;linesearch&#39; must be set to &#39;true&#39;.</p><p>If <code>itmax=0</code>, the default number of iterations is set to <code>2 * n</code>, with <code>n = length(b)</code>.</p><p><strong>References</strong></p><ul><li>M. R. Hestenes and E. Stiefel, <em>Methods of conjugate gradients for solving linear systems</em>, Journal of Research of the National Bureau of Standards, 49(6), pp. 409–436, 1952.</li><li>M-A. Dahito and D. Orban, <em>The Conjugate Residual Method in Linesearch and Trust-Region Methods</em>, SIAM Journal on Optimization, 29(3), pp. 1988–2025, 2019.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/cr.jl#L14-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.symmlq" href="#Krylov.symmlq"><code>Krylov.symmlq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = symmlq(A, b::AbstractVector{T};
                    M=opEye(), λ::T=zero(T), transfer_to_cg::Bool=true,
                    λest::T=zero(T), atol::T=√eps(T), rtol::T=√eps(T),
                    etol::T=√eps(T), window::Int=0, itmax::Int=0,
                    conlim::T=1/√eps(T), verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the shifted linear system</p><pre><code class="language-none">(A + λ I) x = b</code></pre><p>using the SYMMLQ method, where λ is a shift parameter, and A is square and symmetric.</p><p>SYMMLQ produces monotonic errors ‖x*-x‖₂.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite.</p><p><strong>Reference</strong></p><ul><li>C. C. Paige and M. A. Saunders, <em>Solution of Sparse Indefinite Systems of Linear Equations</em>, SIAM Journal on Numerical Analysis, 12(4), pp. 617–629, 1975.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/symmlq.jl#L15-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cg_lanczos" href="#Krylov.cg_lanczos"><code>Krylov.cg_lanczos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cg_lanczos(A, b::AbstractVector{T};
                        M=opEye(), atol::T=√eps(T), rtol::T=√eps(T), itmax::Int=0,
                        check_curvature::Bool=false, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>The Lanczos version of the conjugate gradient method to solve the symmetric linear system</p><pre><code class="language-none">Ax = b</code></pre><p>The method does <em>not</em> abort if A is not definite.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite.</p><p><strong>References</strong></p><ul><li>A. Frommer and P. Maass, <em>Fast CG-Based Methods for Tikhonov-Phillips Regularization</em>, SIAM Journal on Scientific Computing, 20(5), pp. 1831–1850, 1999.</li><li>C. C. Paige and M. A. Saunders, <em>Solution of Sparse Indefinite Systems of Linear Equations</em>, SIAM Journal on Numerical Analysis, 12(4), pp. 617–629, 1975.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/cg_lanczos.jl#L17-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cg_lanczos_shift_seq" href="#Krylov.cg_lanczos_shift_seq"><code>Krylov.cg_lanczos_shift_seq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cg_lanczos_shift_seq(A, b::AbstractVector{T}, shifts::AbstractVector{T};
                                  M=opEye(), atol::T=√eps(T), rtol::T=√eps(T), itmax::Int=0,
                                  check_curvature::Bool=false, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>The Lanczos version of the conjugate gradient method to solve a family of shifted systems</p><pre><code class="language-none">(A + αI) x = b  (α = α₁, ..., αₙ)</code></pre><p>The method does <em>not</em> abort if A + αI is not definite.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/cg_lanczos.jl#L138-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.minres" href="#Krylov.minres"><code>Krylov.minres</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = minres(A, b::AbstractVector{T};
                    M=opEye(), λ::T=zero(T), atol::T=√eps(T)/100,
                    rtol::T=√eps(T)/100, etol::T=√eps(T),
                    window::Int=5, itmax::Int=0, conlim::T=1/√eps(T),
                    verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the shifted linear least-squares problem</p><pre><code class="language-none">minimize ‖b - (A + λ I)x‖₂²</code></pre><p>or the shifted linear system</p><pre><code class="language-none">(A + λ I) x = b</code></pre><p>using the MINRES method, where λ ≥ 0 is a shift parameter, where A is square and symmetric.</p><p>MINRES is formally equivalent to applying CR to Ax=b when A is positive definite, but is typically more stable and also applies to the case where A is indefinite.</p><p>MINRES produces monotonic residuals ‖r‖₂ and optimality residuals ‖Aᵀr‖₂.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite.</p><p><strong>Reference</strong></p><ul><li>C. C. Paige and M. A. Saunders, <em>Solution of Sparse Indefinite Systems of Linear Equations</em>, SIAM Journal on Numerical Analysis, 12(4), pp. 617–629, 1975.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/minres.jl#L25-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.minres_qlp" href="#Krylov.minres_qlp"><code>Krylov.minres_qlp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = minres_qlp(A, b::AbstractVector{T};
                        M=opEye(), atol::T=√eps(T), rtol::T=√eps(T), λ::T=zero(T),
                        itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>MINRES-QLP is the only method based on the Lanczos process that returns the minimum-norm solution on singular inconsistent systems (A + λI)x = b, where λ is a shift parameter. It is significantly more complex but can be more reliable than MINRES when A is ill-conditioned.</p><p>A preconditioner M may be provided in the form of a linear operator and is assumed to be symmetric and positive definite. M also indicates the weighted norm in which residuals are measured.</p><p><strong>References</strong></p><ul><li>S.-C. T. Choi, <em>Iterative methods for singular linear equations and least-squares problems</em>, Ph.D. thesis, ICME, Stanford University, 2006.</li><li>S.-C. T. Choi, C. C. Paige and M. A. Saunders, <em>MINRES-QLP: A Krylov subspace method for indefinite or singular symmetric systems</em>, SIAM Journal on Scientific Computing, Vol. 33(4), pp. 1810–1836, 2011.</li><li>S.-C. T. Choi and M. A. Saunders, <em>Algorithm 937: MINRES-QLP for symmetric and Hermitian linear equations and least-squares problems</em>, ACM Transactions on Mathematical Software, 40(2), pp. 1–12, 2014.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/minres_qlp.jl#L19-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.diom" href="#Krylov.diom"><code>Krylov.diom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = diom(A, b::AbstractVector{T};
                  M=opEye(), N=opEye(), atol::T=√eps(T), rtol::T=√eps(T), itmax::Int=0,
                  memory::Int=20, pivoting::Bool=false, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the consistent linear system Ax = b using direct incomplete orthogonalization method.</p><p>DIOM is similar to CG with partial reorthogonalization.</p><p>An advantage of DIOM is that nonsymmetric or symmetric indefinite or both nonsymmetric and indefinite systems of linear equations can be handled by this single algorithm.</p><p>This implementation allows a left preconditioner M and a right preconditioner N.</p><ul><li>Left  preconditioning : M⁻¹Ax = M⁻¹b</li><li>Right preconditioning : AN⁻¹u = b with x = N⁻¹u</li><li>Split preconditioning : M⁻¹AN⁻¹u = M⁻¹b with x = N⁻¹u</li></ul><p><strong>Reference</strong></p><ul><li>Y. Saad, <em>Practical use of some krylov subspace methods for solving indefinite and nonsymmetric linear systems</em>, SIAM journal on scientific and statistical computing, 5(1), pp. 203–228, 1984.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/diom.jl#L13-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.dqgmres" href="#Krylov.dqgmres"><code>Krylov.dqgmres</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = dqgmres(A, b::AbstractVector{T};
                     M=opEye(), N=opEye(), atol::T=√eps(T), rtol::T=√eps(T),
                     itmax::Int=0, memory::Int=20, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the consistent linear system Ax = b using DQGMRES method.</p><p>DQGMRES algorithm is based on the incomplete Arnoldi orthogonalization process and computes a sequence of approximate solutions with the quasi-minimal residual property.</p><p>This implementation allows a left preconditioner M and a right preconditioner N.</p><ul><li>Left  preconditioning : M⁻¹Ax = M⁻¹b</li><li>Right preconditioning : AN⁻¹u = b with x = N⁻¹u</li><li>Split preconditioning : M⁻¹AN⁻¹u = M⁻¹b with x = N⁻¹u</li></ul><p><strong>Reference</strong></p><ul><li>Y. Saad and K. Wu, <em>DQGMRES: a quasi minimal residual algorithm based on incomplete orthogonalization</em>, Numerical Linear Algebra with Applications, Vol. 3(4), pp. 329–343, 1996.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/dqgmres.jl#L13-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.usymlq" href="#Krylov.usymlq"><code>Krylov.usymlq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = usymlq(A, b::AbstractVector{T}, c::AbstractVector{T};
                    atol::T=√eps(T), rtol::T=√eps(T), transfer_to_usymcg::Bool=true,
                    itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the linear system Ax = b using the USYMLQ method.</p><p>USYMLQ is based on a tridiagonalization process for unsymmetric matrices. The error norm ‖x - x*‖ monotonously decreases in USYMLQ. It&#39;s considered as a generalization of SYMMLQ.</p><p>It can also be applied to under-determined and over-determined problems. In all cases, problems must be consistent.</p><p>An option gives the possibility of transferring to the USYMCG point, when it exists. The transfer is based on the residual norm.</p><p><strong>References</strong></p><ul><li>M. A. Saunders, H. D. Simon, and E. L. Yip, <em>Two Conjugate-Gradient-Type Methods for Unsymmetric Linear Equations</em>, SIAM Journal on Numerical Analysis, 25(4), pp. 927–940, 1988.</li><li>A. Buttari, D. Orban, D. Ruiz and D. Titley-Peloquin, <em>A tridiagonalization method for symmetric saddle-point and quasi-definite systems</em>, SIAM Journal on Scientific Computing, 41(5), pp. 409–432, 2019.</li><li>A. Montoison and D. Orban, <em>BiLQ: An Iterative Method for Nonsymmetric Linear Systems with a Quasi-Minimum Error Property</em>, SIAM Journal on Matrix Analysis and Applications, 41(3), pp. 1145–1166, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/usymlq.jl#L22-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.usymqr" href="#Krylov.usymqr"><code>Krylov.usymqr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = usymqr(A, b::AbstractVector{T}, c::AbstractVector{T};
                    atol::T=√eps(T), rtol::T=√eps(T),
                    itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the linear system Ax = b using the USYMQR method.</p><p>USYMQR is based on a tridiagonalization process for unsymmetric matrices. The residual norm ‖b - Ax‖ monotonously decreases in USYMQR. It&#39;s considered as a generalization of MINRES.</p><p>It can also be applied to under-determined and over-determined problems. USYMQR finds the minimum-norm solution if problems are inconsistent.</p><p><strong>References</strong></p><ul><li>M. A. Saunders, H. D. Simon, and E. L. Yip, <em>Two Conjugate-Gradient-Type Methods for Unsymmetric Linear Equations</em>, SIAM Journal on Numerical Analysis, 25(4), pp. 927–940, 1988.</li><li>A. Buttari, D. Orban, D. Ruiz and D. Titley-Peloquin, <em>A tridiagonalization method for symmetric saddle-point and quasi-definite systems</em>, SIAM Journal on Scientific Computing, 41(5), pp. 409–432, 2019.</li><li>A. Montoison and D. Orban, <em>BiLQ: An Iterative Method for Nonsymmetric Linear Systems with a Quasi-Minimum Error Property</em>, SIAM Journal on Matrix Analysis and Applications, 41(3), pp. 1145–1166, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/usymqr.jl#L22-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.tricg" href="#Krylov.tricg"><code>Krylov.tricg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, y, stats) = tricg(A, b::AbstractVector{T}, c::AbstractVector{T};
                      M=opEye(), N=opEye(), atol::T=√eps(T), rtol::T=√eps(T),
                      spd::Bool=false, snd::Bool=false, flip::Bool=false,
                      τ::T=one(T), ν::T=-one(T), itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>TriCG solves the symmetric linear system</p><pre><code class="language-none">[ τE    A ] [ x ] = [ b ]
[  Aᵀ  νF ] [ y ]   [ c ],</code></pre><p>where τ and ν are real numbers, E = M⁻¹ ≻ 0 and F = N⁻¹ ≻ 0. TriCG could breakdown if <code>τ = 0</code> or <code>ν = 0</code>. It&#39;s recommended to use TriMR in these cases.</p><p>By default, TriCG solves symmetric and quasi-definite linear systems with τ = 1 and ν = -1. If <code>flip = true</code>, TriCG solves another known variant of SQD systems where τ = -1 and ν = 1. If <code>spd = true</code>, τ = ν = 1 and the associated symmetric and positive definite linear system is solved. If <code>snd = true</code>, τ = ν = -1 and the associated symmetric and negative definite linear system is solved. <code>τ</code> and <code>ν</code> are also keyword arguments that can be directly modified for more specific problems.</p><p>TriCG is based on the preconditioned orthogonal tridiagonalization process and its relation with the preconditioned block-Lanczos process.</p><pre><code class="language-none">[ M   O ]
[ 0   N ]</code></pre><p>indicates the weighted norm in which residuals are measured. It&#39;s the Euclidean norm when <code>M</code> and <code>N</code> are identity operators.</p><p>TriCG stops when <code>itmax</code> iterations are reached or when <code>‖rₖ‖ ≤ atol + ‖r₀‖ * rtol</code>. <code>atol</code> is an absolute tolerance and <code>rtol</code> is a relative tolerance.</p><p>Additional details can be displayed if verbose mode is enabled (verbose &gt; 0). Information will be displayed every <code>verbose</code> iterations.</p><p><strong>Reference</strong></p><ul><li>A. Montoison and D. Orban, <em>TriCG and TriMR: Two Iterative Methods for Symmetric Quasi-Definite Systems</em>, Cahier du GERAD G-2020-41, GERAD, Montréal, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/tricg.jl#L14-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.trimr" href="#Krylov.trimr"><code>Krylov.trimr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, y, stats) = trimr(A, b::AbstractVector{T}, c::AbstractVector{T};
                      M=opEye(), N=opEye(), atol::T=√eps(T), rtol::T=√eps(T),
                      spd::Bool=false, snd::Bool=false, flip::Bool=false, sp::Bool=false,
                      τ::T=one(T), ν::T=-one(T), itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>TriMR solves the symmetric linear system</p><pre><code class="language-none">[ τE    A ] [ x ] = [ b ]
[  Aᵀ  νF ] [ y ]   [ c ],</code></pre><p>where τ and ν are real numbers, E = M⁻¹ ≻ 0 and F = N⁻¹ ≻ 0. TriMR handles saddle-point systems (<code>τ = 0</code> or <code>ν = 0</code>) and adjoint systems (<code>τ = 0</code> and <code>ν = 0</code>) without any risk of breakdown.</p><p>By default, TriMR solves symmetric and quasi-definite linear systems with τ = 1 and ν = -1. If <code>flip = true</code>, TriMR solves another known variant of SQD systems where τ = -1 and ν = 1. If <code>spd = true</code>, τ = ν = 1 and the associated symmetric and positive definite linear system is solved. If <code>snd = true</code>, τ = ν = -1 and the associated symmetric and negative definite linear system is solved. If <code>sp = true</code>, τ = 1, ν = 0 and the associated saddle-point linear system is solved. <code>τ</code> and <code>ν</code> are also keyword arguments that can be directly modified for more specific problems.</p><p>TriMR is based on the preconditioned orthogonal tridiagonalization process and its relation with the preconditioned block-Lanczos process.</p><pre><code class="language-none">[ M   O ]
[ 0   N ]</code></pre><p>indicates the weighted norm in which residuals are measured. It&#39;s the Euclidean norm when <code>M</code> and <code>N</code> are identity operators.</p><p>TriMR stops when <code>itmax</code> iterations are reached or when <code>‖rₖ‖ ≤ atol + ‖r₀‖ * rtol</code>. <code>atol</code> is an absolute tolerance and <code>rtol</code> is a relative tolerance.</p><p>Additional details can be displayed if verbose mode is enabled (verbose &gt; 0). Information will be displayed every <code>verbose</code> iterations.</p><p><strong>Reference</strong></p><ul><li>A. Montoison and D. Orban, <em>TriCG and TriMR: Two Iterative Methods for Symmetric Quasi-Definite Systems</em>, Cahier du GERAD G-2020-41, GERAD, Montréal, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/trimr.jl#L14-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.trilqr" href="#Krylov.trilqr"><code>Krylov.trilqr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, t, stats) = trilqr(A, b::AbstractVector{T}, c::AbstractVector{T};
                       atol::T=√eps(T), rtol::T=√eps(T), transfer_to_usymcg::Bool=true,
                       itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Combine USYMLQ and USYMQR to solve adjoint systems.</p><pre><code class="language-none">[0  A] [t] = [b]
[Aᵀ 0] [x]   [c]</code></pre><p>USYMLQ is used for solving primal system <code>Ax = b</code>. USYMQR is used for solving dual system <code>Aᵀt = c</code>.</p><p>An option gives the possibility of transferring from the USYMLQ point to the USYMCG point, when it exists. The transfer is based on the residual norm.</p><p><strong>Reference</strong></p><ul><li>A. Montoison and D. Orban, <em>BiLQ: An Iterative Method for Nonsymmetric Linear Systems with a Quasi-Minimum Error Property</em>, SIAM Journal on Matrix Analysis and Applications, 41(3), pp. 1145–1166, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/trilqr.jl#L15-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.bilq" href="#Krylov.bilq"><code>Krylov.bilq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = bilq(A, b::AbstractVector{T}; c::AbstractVector{T}=b,
                  atol::T=√eps(T), rtol::T=√eps(T), transfer_to_bicg::Bool=true,
                  itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the square linear system Ax = b using the BiLQ method.</p><p>BiLQ is based on the Lanczos biorthogonalization process. When A is symmetric and b = c, BiLQ is equivalent to SYMMLQ.</p><p>An option gives the possibility of transferring to the BiCG point, when it exists. The transfer is based on the residual norm.</p><p><strong>Reference</strong></p><ul><li>A. Montoison and D. Orban, <em>BiLQ: An Iterative Method for Nonsymmetric Linear Systems with a Quasi-Minimum Error Property</em>, SIAM Journal on Matrix Analysis and Applications, 41(3), pp. 1145–1166, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/bilq.jl#L15-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cgs" href="#Krylov.cgs"><code>Krylov.cgs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cgs(A, b::AbstractVector{T}; c::AbstractVector{T}=b,
                 M=opEye(), N=opEye(), atol::T=√eps(T), rtol::T=√eps(T),
                 itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the consistent linear system Ax = b using conjugate gradient squared algorithm.</p><p>From &quot;Iterative Methods for Sparse Linear Systems (Y. Saad)&quot; :</p><p>«The method is based on a polynomial variant of the conjugate gradients algorithm. Although related to the so-called bi-conjugate gradients (BCG) algorithm, it does not involve adjoint matrix-vector multiplications, and the expected convergence rate is about twice that of the BCG algorithm.</p><p>The Conjugate Gradient Squared algorithm works quite well in many cases. However, one difficulty is that, since the polynomials are squared, rounding errors tend to be more damaging than in the standard BCG algorithm. In particular, very high variations of the residual vectors often cause the residual norms computed to become inaccurate.</p><p>TFQMR and BICGSTAB were developed to remedy this difficulty.»</p><p>This implementation allows a left preconditioner M and a right preconditioner N.</p><p><strong>Reference</strong></p><ul><li>P. Sonneveld, <em>CGS, A Fast Lanczos-Type Solver for Nonsymmetric Linear systems</em>, SIAM Journal on Scientific and Statistical Computing, 10(1), pp. 36–52, 1989.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/cgs.jl#L13-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.bicgstab" href="#Krylov.bicgstab"><code>Krylov.bicgstab</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = bicgstab(A, b::AbstractVector{T}; c::AbstractVector{T}=b,
                      M=opEye(), N=opEye(), atol::T=√eps(T), rtol::T=√eps(T),
                      itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the square linear system Ax = b using the BICGSTAB method.</p><p>The Biconjugate Gradient Stabilized method is a variant of BiCG, like CGS, but using different updates for the Aᵀ-sequence in order to obtain smoother convergence than CGS.</p><p>If BICGSTAB stagnates, we recommend DQGMRES and BiLQ as alternative methods for unsymmetric square systems.</p><p>BICGSTAB stops when <code>itmax</code> iterations are reached or when <code>‖rₖ‖ ≤ atol + ‖b‖ * rtol</code>. <code>atol</code> is an absolute tolerance and <code>rtol</code> is a relative tolerance.</p><p>Additional details can be displayed if verbose mode is enabled (verbose &gt; 0). Information will be displayed every <code>verbose</code> iterations.</p><p>This implementation allows a left preconditioner <code>M</code> and a right preconditioner <code>N</code>.</p><p><strong>References</strong></p><ul><li>H. A. van der Vorst, <em>Bi-CGSTAB: A fast and smoothly converging variant of Bi-CG for the solution of nonsymmetric linear systems</em>, SIAM Journal on Scientific and Statistical Computing, 13(2), pp. 631–644, 1992.</li><li>G. L.G. Sleijpen and D. R. Fokkema, <em>BiCGstab(ℓ) for linear equations involving unsymmetric matrices with complex spectrum</em>, Electronic Transactions on Numerical Analysis, 1, pp. 11–32, 1993.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/bicgstab.jl#L18-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.qmr" href="#Krylov.qmr"><code>Krylov.qmr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = qmr(A, b::AbstractVector{T}; c::AbstractVector{T}=b,
                 atol::T=√eps(T), rtol::T=√eps(T),
                 itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the square linear system Ax = b using the QMR method.</p><p>QMR is based on the Lanczos biorthogonalization process. When A is symmetric and b = c, QMR is equivalent to MINRES.</p><p><strong>References</strong></p><ul><li>R. W. Freund and N. M. Nachtigal, <em>QMR : a quasi-minimal residual method for non-Hermitian linear systems</em>, Numerische mathematik, Vol. 60(1), pp. 315–339, 1991.</li><li>R. W. Freund and N. M. Nachtigal, <em>An implementation of the QMR method based on coupled two-term recurrences</em>, SIAM Journal on Scientific Computing, Vol. 15(2), pp. 313–337, 1994.</li><li>A. Montoison and D. Orban, <em>BiLQ: An Iterative Method for Nonsymmetric Linear Systems with a Quasi-Minimum Error Property</em>, SIAM Journal on Matrix Analysis and Applications, 41(3), pp. 1145–1166, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/qmr.jl#L23-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.bilqr" href="#Krylov.bilqr"><code>Krylov.bilqr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, t, stats) = bilqr(A, b::AbstractVector{T}, c::AbstractVector{T};
                      atol::T=√eps(T), rtol::T=√eps(T), transfer_to_bicg::Bool=true,
                      itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Combine BiLQ and QMR to solve adjoint systems.</p><pre><code class="language-none">[0  A] [t] = [b]
[Aᵀ 0] [x]   [c]</code></pre><p>BiLQ is used for solving primal system <code>Ax = b</code>. QMR is used for solving dual system <code>Aᵀt = c</code>.</p><p>An option gives the possibility of transferring from the BiLQ point to the BiCG point, when it exists. The transfer is based on the residual norm.</p><p><strong>Reference</strong></p><ul><li>A. Montoison and D. Orban, <em>BiLQ: An Iterative Method for Nonsymmetric Linear Systems with a Quasi-Minimum Error Property</em>, SIAM Journal on Matrix Analysis and Applications, 41(3), pp. 1145–1166, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/bilqr.jl#L15-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cgls" href="#Krylov.cgls"><code>Krylov.cgls</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cgls(A, b::AbstractVector{T};
                  M=opEye(), λ::T=zero(T), atol::T=√eps(T), rtol::T=√eps(T),
                  radius::T=zero(T), itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the regularized linear least-squares problem</p><pre><code class="language-none">minimize ‖b - Ax‖₂² + λ ‖x‖₂²</code></pre><p>using the Conjugate Gradient (CG) method, where λ ≥ 0 is a regularization parameter. This method is equivalent to applying CG to the normal equations</p><pre><code class="language-none">(AᵀA + λI) x = Aᵀb</code></pre><p>but is more stable.</p><p>CGLS produces monotonic residuals ‖r‖₂ but not optimality residuals ‖Aᵀr‖₂. It is formally equivalent to LSQR, though can be slightly less accurate, but simpler to implement.</p><p><strong>References</strong></p><ul><li>M. R. Hestenes and E. Stiefel. <em>Methods of conjugate gradients for solving linear systems</em>, Journal of Research of the National Bureau of Standards, 49(6), pp. 409–436, 1952.</li><li>A. Björck, T. Elfving and Z. Strakos, <em>Stability of Conjugate Gradient and Lanczos Methods for Linear Least Squares Problems</em>, SIAM Journal on Matrix Analysis and Applications, 19(3), pp. 720–736, 1998.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/cgls.jl#L32-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.crls" href="#Krylov.crls"><code>Krylov.crls</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = crls(A, b::AbstractVector{T};
                  M=opEye(), λ::T=zero(T), atol::T=√eps(T), rtol::T=√eps(T),
                  radius::T=zero(T), itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the linear least-squares problem</p><pre><code class="language-none">minimize ‖b - Ax‖₂² + λ ‖x‖₂²</code></pre><p>using the Conjugate Residuals (CR) method. This method is equivalent to applying MINRES to the normal equations</p><pre><code class="language-none">(AᵀA + λI) x = Aᵀb.</code></pre><p>This implementation recurs the residual r := b - Ax.</p><p>CRLS produces monotonic residuals ‖r‖₂ and optimality residuals ‖Aᵀr‖₂. It is formally equivalent to LSMR, though can be substantially less accurate, but simpler to implement.</p><p><strong>Reference</strong></p><ul><li>D. C.-L. Fong, <em>Minimum-Residual Methods for Sparse, Least-Squares using Golubg-Kahan Bidiagonalization</em>, Ph.D. Thesis, Stanford University, 2011.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/crls.jl#L24-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.cgne" href="#Krylov.cgne"><code>Krylov.cgne</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = cgne(A, b::AbstractVector{T};
                  M=opEye(), λ::T=zero(T), atol::T=√eps(T), rtol::T=√eps(T),
                  itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the consistent linear system</p><pre><code class="language-none">Ax + √λs = b</code></pre><p>using the Conjugate Gradient (CG) method, where λ ≥ 0 is a regularization parameter. This method is equivalent to applying CG to the normal equations of the second kind</p><pre><code class="language-none">(AAᵀ + λI) y = b</code></pre><p>but is more stable. When λ = 0, this method solves the minimum-norm problem</p><p>min ‖x‖₂  s.t. Ax = b.</p><p>When λ &gt; 0, it solves the problem</p><pre><code class="language-none">min ‖(x,s)‖₂  s.t. Ax + √λs = b.</code></pre><p>CGNE produces monotonic errors ‖x-x*‖₂ but not residuals ‖r‖₂. It is formally equivalent to CRAIG, though can be slightly less accurate, but simpler to implement. Only the x-part of the solution is returned.</p><p>A preconditioner M may be provided in the form of a linear operator.</p><p><strong>References</strong></p><ul><li>J. E. Craig, <em>The N-step iteration procedures</em>, Journal of Mathematics and Physics, 34(1), pp. 64–73, 1955.</li><li>J. E. Craig, <em>Iterations Procedures for Simultaneous Equations</em>, Ph.D. Thesis, Department of Electrical Engineering, MIT, 1954.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/cgne.jl#L32-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.crmr" href="#Krylov.crmr"><code>Krylov.crmr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = crmr(A, b::AbstractVector{T};
                  M=opEye(), λ::T=zero(T), atol::T=√eps(T),
                  rtol::T=√eps(T), itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the consistent linear system</p><pre><code class="language-none">Ax + √λs = b</code></pre><p>using the Conjugate Residual (CR) method, where λ ≥ 0 is a regularization parameter. This method is equivalent to applying CR to the normal equations of the second kind</p><pre><code class="language-none">(AAᵀ + λI) y = b</code></pre><p>but is more stable. When λ = 0, this method solves the minimum-norm problem</p><pre><code class="language-none">min ‖x‖₂  s.t.  x ∈ argmin ‖Ax - b‖₂.</code></pre><p>When λ &gt; 0, this method solves the problem</p><pre><code class="language-none">min ‖(x,s)‖₂  s.t. Ax + √λs = b.</code></pre><p>CGMR produces monotonic residuals ‖r‖₂. It is formally equivalent to CRAIG-MR, though can be slightly less accurate, but simpler to implement. Only the x-part of the solution is returned.</p><p>A preconditioner M may be provided in the form of a linear operator.</p><p><strong>References</strong></p><ul><li>D. Orban and M. Arioli, <em>Iterative Solution of Symmetric Quasi-Definite Linear Systems</em>, Volume 3 of Spotlights. SIAM, Philadelphia, PA, 2017.</li><li>D. Orban, <em>The Projected Golub-Kahan Process for Constrained Linear Least-Squares Problems</em>. Cahier du GERAD G-2014-15, 2014.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/crmr.jl#L30-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.lslq" href="#Krylov.lslq"><code>Krylov.lslq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x_lq, x_cg, err_lbnds, err_ubnds_lq, err_ubnds_cg, stats) =
    lslq(A, b::AbstractVector{T};
         M=opEye(), N=opEye(), sqd::Bool=false, λ::T=zero(T),
         atol::T=√eps(T), btol::T=√eps(T), etol::T=√eps(T),
         window::Int=5, utol::T=√eps(T), itmax::Int=0,
         σ::T=zero(T), conlim::T=1/√eps(T), verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the regularized linear least-squares problem</p><pre><code class="language-none">minimize ‖b - Ax‖₂² + λ² ‖x‖₂²</code></pre><p>using the LSLQ method, where λ ≥ 0 is a regularization parameter. LSLQ is formally equivalent to applying SYMMLQ to the normal equations</p><pre><code class="language-none">(AᵀA + λ² I) x = Aᵀb</code></pre><p>but is more stable.</p><p><strong>Main features</strong></p><ul><li>the solution estimate is updated along orthogonal directions</li><li>the norm of the solution estimate ‖xᴸₖ‖₂ is increasing</li><li>the error ‖eₖ‖₂ := ‖xᴸₖ - x*‖₂ is decreasing</li><li>it is possible to transition cheaply from the LSLQ iterate to the LSQR iterate if there is an advantage (there always is in terms of error)</li><li>if <code>A</code> is rank deficient, identify the minimum least-squares solution</li></ul><p><strong>Input arguments</strong></p><ul><li><code>A::AbstractLinearOperator</code></li><li><code>b::Vector{Float64}</code></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>M::AbstractLinearOperator=opEye()</code>: a symmetric and positive definite dual preconditioner</li><li><code>N::AbstractLinearOperator=opEye()</code>: a symmetric and positive definite primal preconditioner</li><li><code>sqd::Bool=false</code> indicates whether or not we are solving a symmetric and quasi-definite augmented system</li></ul><p>If <code>sqd = true</code>, we solve the symmetric and quasi-definite system</p><pre><code class="language-none">[ E    A ] [ r ]   [ b ]
[ Aᵀ  -F ] [ x ] = [ 0 ],</code></pre><p>where E and F are symmetric and positive definite. LSLQ is then equivalent to applying SYMMLQ to <code>(AᵀE⁻¹A + F)y = AᵀE⁻¹b</code> with <code>r = E⁻¹(b - Ax)</code>. Preconditioners M = E⁻¹ ≻ 0 and N = F⁻¹ ≻ 0 may be provided in the form of linear operators.</p><p>If <code>sqd</code> is set to <code>false</code> (the default), we solve the symmetric and indefinite system</p><pre><code class="language-none">[ E    A ] [ r ]   [ b ]
[ Aᵀ   0 ] [ x ] = [ 0 ].</code></pre><p>In this case, <code>N</code> can still be specified and indicates the weighted norm in which <code>x</code> and <code>Aᵀr</code> should be measured. <code>r</code> can be recovered by computing <code>E⁻¹(b - Ax)</code>.</p><ul><li><code>λ::Float64=0.0</code> is a regularization parameter (see the problem statement above)</li><li><code>σ::Float64=0.0</code> is an underestimate of the smallest nonzero singular value of <code>A</code>–-setting <code>σ</code> too large will result in an error in the course of the iterations</li><li><code>atol::Float64=1.0e-8</code> is a stopping tolerance based on the residual</li><li><code>btol::Float64=1.0e-8</code> is a stopping tolerance used to detect zero-residual problems</li><li><code>etol::Float64=1.0e-8</code> is a stopping tolerance based on the lower bound on the error</li><li><code>window::Int=5</code> is the number of iterations used to accumulate a lower bound on the error</li><li><code>utol::Float64=1.0e-8</code> is a stopping tolerance based on the upper bound on the error</li><li><code>itmax::Int=0</code> is the maximum number of iterations (0 means no imposed limit)</li><li><code>conlim::Float64=1.0e+8</code> is the limit on the estimated condition number of <code>A</code> beyond which the solution will be abandoned</li><li><code>verbose::Int=0</code> determines verbosity.</li></ul><p><strong>Return values</strong></p><p><code>lslq()</code> returns the tuple <code>(x_lq, x_cg, err_lbnds, err_ubnds_lq, err_ubnds_cg, stats)</code> where</p><ul><li><code>x_lq::Vector{Float64}</code> is the LQ solution estimate</li><li><code>x_cg::Vector{Float64}</code> is the CG solution estimate (i.e., the LSQR point)</li><li><code>err_lbnds::Vector{Float64}</code> is a vector of lower bounds on the LQ error–-the vector is empty if <code>window</code> is set to zero</li><li><code>err_ubnds_lq::Vector{Float64}</code> is a vector of upper bounds on the LQ error–-the vector is empty if <code>σ == 0</code> is left at zero</li><li><code>err_ubnds_cg::Vector{Float64}</code> is a vector of upper bounds on the CG error–-the vector is empty if <code>σ == 0</code> is left at zero</li><li><code>stats::SimpleStats</code> collects other statistics on the run.</li></ul><p><strong>Stopping conditions</strong></p><p>The iterations stop as soon as one of the following conditions holds true:</p><ul><li>the optimality residual is sufficiently small (<code>stats.status = &quot;found approximate minimum least-squares solution&quot;</code>) in the sense that either<ul><li>‖Aᵀr‖ / (‖A‖ ‖r‖) ≤ atol, or</li><li>1 + ‖Aᵀr‖ / (‖A‖ ‖r‖) ≤ 1</li></ul></li><li>an approximate zero-residual solution has been found (<code>stats.status = &quot;found approximate zero-residual solution&quot;</code>) in the sense that either<ul><li>‖r‖ / ‖b‖ ≤ btol + atol ‖A‖ * ‖xᴸ‖ / ‖b‖, or</li><li>1 + ‖r‖ / ‖b‖ ≤ 1</li></ul></li><li>the estimated condition number of <code>A</code> is too large in the sense that either<ul><li>1/cond(A) ≤ 1/conlim (<code>stats.status = &quot;condition number exceeds tolerance&quot;</code>), or</li><li>1 + 1/cond(A) ≤ 1 (<code>stats.status = &quot;condition number seems too large for this machine&quot;</code>)</li></ul></li><li>the lower bound on the LQ forward error is less than etol * ‖xᴸ‖</li><li>the upper bound on the CG forward error is less than utol * ‖xᶜ‖</li></ul><p><strong>References</strong></p><ul><li>R. Estrin, D. Orban and M. A. Saunders, <em>Euclidean-norm error bounds for SYMMLQ and CG</em>, SIAM Journal on Matrix Analysis and Applications, 40(1), pp. 235–253, 2019.</li><li>R. Estrin, D. Orban and M. A. Saunders, <em>LSLQ: An Iterative Method for Linear Least-Squares with an Error Minimization Property</em>, SIAM Journal on Matrix Analysis and Applications, 40(1), pp. 254–275, 2019.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/lslq.jl#L7-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.lsqr" href="#Krylov.lsqr"><code>Krylov.lsqr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = lsqr(A, b::AbstractVector{T};
                  M=opEye(), N=opEye(), sqd::Bool=false,
                  λ::T=zero(T), axtol::T=√eps(T), btol::T=√eps(T),
                  atol::T=zero(T), rtol::T=zero(T),
                  etol::T=√eps(T), window::Int=5,
                  itmax::Int=0, conlim::T=1/√eps(T),
                  radius::T=zero(T), verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the regularized linear least-squares problem</p><pre><code class="language-none">minimize ‖b - Ax‖₂² + λ² ‖x‖₂²</code></pre><p>using the LSQR method, where λ ≥ 0 is a regularization parameter. LSQR is formally equivalent to applying CG to the normal equations</p><pre><code class="language-none">(AᵀA + λ² I) x = Aᵀb</code></pre><p>(and therefore to CGLS) but is more stable.</p><p>LSQR produces monotonic residuals ‖r‖₂ but not optimality residuals ‖Aᵀr‖₂. It is formally equivalent to CGLS, though can be slightly more accurate.</p><p>Preconditioners M and N may be provided in the form of linear operators and are assumed to be symmetric and positive definite. If <code>sqd</code> is set to <code>true</code>, we solve the symmetric and quasi-definite system</p><pre><code class="language-none">[ E    A ] [ r ]   [ b ]
[ Aᵀ  -F ] [ x ] = [ 0 ],</code></pre><p>where E and F are symmetric and positive definite. LSQR is then equivalent to applying CG to <code>(AᵀE⁻¹A + F)y = AᵀE⁻¹b</code> with <code>r = E⁻¹(b - Ax)</code>. Preconditioners M = E⁻¹ ≻ 0 and N = F⁻¹ ≻ 0 may be provided in the form of linear operators.</p><p>If <code>sqd</code> is set to <code>false</code> (the default), we solve the symmetric and indefinite system</p><pre><code class="language-none">[ E    A ] [ r ]   [ b ]
[ Aᵀ   0 ] [ x ] = [ 0 ].</code></pre><p>In this case, <code>N</code> can still be specified and indicates the weighted norm in which <code>x</code> and <code>Aᵀr</code> should be measured. <code>r</code> can be recovered by computing <code>E⁻¹(b - Ax)</code>.</p><p><strong>Reference</strong></p><ul><li>C. C. Paige and M. A. Saunders, <em>LSQR: An Algorithm for Sparse Linear Equations and Sparse Least Squares</em>, ACM Transactions on Mathematical Software, 8(1), pp. 43–71, 1982.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/lsqr.jl#L28-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.lsmr" href="#Krylov.lsmr"><code>Krylov.lsmr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, stats) = lsmr(A, b::AbstractVector{T};
                  M=opEye(), N=opEye(), sqd::Bool=false,
                  λ::T=zero(T), axtol::T=√eps(T), btol::T=√eps(T),
                  atol::T=zero(T), rtol::T=zero(T),
                  etol::T=√eps(T), window::Int=5,
                  itmax::Int=0, conlim::T=1/√eps(T),
                  radius::T=zero(T), verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the regularized linear least-squares problem</p><pre><code class="language-none">minimize ‖b - Ax‖₂² + λ² ‖x‖₂²</code></pre><p>using the LSMR method, where λ ≥ 0 is a regularization parameter. LSQR is formally equivalent to applying MINRES to the normal equations</p><pre><code class="language-none">(AᵀA + λ² I) x = Aᵀb</code></pre><p>(and therefore to CRLS) but is more stable.</p><p>LSMR produces monotonic residuals ‖r‖₂ and optimality residuals ‖Aᵀr‖₂. It is formally equivalent to CRLS, though can be substantially more accurate.</p><p>Preconditioners M and N may be provided in the form of linear operators and are assumed to be symmetric and positive definite. If <code>sqd</code> is set to <code>true</code>, we solve the symmetric and quasi-definite system</p><pre><code class="language-none">[ E    A ] [ r ]   [ b ]
[ Aᵀ  -F ] [ x ] = [ 0 ],</code></pre><p>where E and F are symmetric and positive definite. LSMR is then equivalent to applying MINRES to <code>(AᵀE⁻¹A + F)y = AᵀE⁻¹b</code> with <code>r = E⁻¹(b - Ax)</code>. Preconditioners M = E⁻¹ ≻ 0 and N = F⁻¹ ≻ 0 may be provided in the form of linear operators.</p><p>If <code>sqd</code> is set to <code>false</code> (the default), we solve the symmetric and indefinite system</p><pre><code class="language-none">[ E    A ] [ r ]   [ b ]
[ Aᵀ   0 ] [ x ] = [ 0 ].</code></pre><p>In this case, <code>N</code> can still be specified and indicates the weighted norm in which <code>x</code> and <code>Aᵀr</code> should be measured. <code>r</code> can be recovered by computing <code>E⁻¹(b - Ax)</code>.</p><p><strong>Reference</strong></p><ul><li>D. C.-L. Fong and M. A. Saunders, <em>LSMR: An Iterative Algorithm for Sparse</em>, Least Squares Problems, SIAM Journal on Scientific Computing, 33(5), pp. 2950–2971, 2011.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/lsmr.jl#L28-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.craig" href="#Krylov.craig"><code>Krylov.craig</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, y, stats) = craig(A, b::AbstractVector{T};
                      M=opEye(), N=opEye(), sqd::Bool=false, λ::T=zero(T), atol::T=√eps(T),
                      btol::T=√eps(T), rtol::T=√eps(T), conlim::T=1/√eps(T), itmax::Int=0,
                      verbose::Int=0, transfer_to_lsqr::Bool=false) where T &lt;: AbstractFloat</code></pre><p>Find the least-norm solution of the consistent linear system</p><pre><code class="language-none">Ax + λs = b</code></pre><p>using the Golub-Kahan implementation of Craig&#39;s method, where λ ≥ 0 is a regularization parameter. This method is equivalent to CGNE but is more stable.</p><p>For a system in the form Ax = b, Craig&#39;s method is equivalent to applying CG to AAᵀy = b and recovering x = Aᵀy. Note that y are the Lagrange multipliers of the least-norm problem</p><pre><code class="language-none">minimize ‖x‖  s.t.  Ax = b.</code></pre><p>Preconditioners M⁻¹ and N⁻¹ may be provided in the form of linear operators and are assumed to be symmetric and positive definite. If <code>sqd = true</code>, CRAIG solves the symmetric and quasi-definite system</p><pre><code class="language-none">[ -N   Aᵀ ] [ x ]   [ 0 ]
[  A   M  ] [ y ] = [ b ],</code></pre><p>which is equivalent to applying CG to <code>(AN⁻¹Aᵀ + M)y = b</code> with <code>Nx = Aᵀy</code>.</p><p>If <code>sqd = false</code>, CRAIG solves the symmetric and indefinite system</p><pre><code class="language-none">[ -N   Aᵀ ] [ x ]   [ 0 ]
[  A   0  ] [ y ] = [ b ].</code></pre><p>In this case, M⁻¹ can still be specified and indicates the weighted norm in which residuals are measured.</p><p>In this implementation, both the x and y-parts of the solution are returned.</p><p><strong>References</strong></p><ul><li>C. C. Paige and M. A. Saunders, <em>LSQR: An Algorithm for Sparse Linear Equations and Sparse Least Squares</em>, ACM Transactions on Mathematical Software, 8(1), pp. 43–71, 1982.</li><li>M. A. Saunders, <em>Solutions of Sparse Rectangular Systems Using LSQR and CRAIG</em>, BIT Numerical Mathematics, 35(4), pp. 588–604, 1995.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/craig.jl#L36-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Krylov.craigmr" href="#Krylov.craigmr"><code>Krylov.craigmr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x, y, stats) = craigmr(A, b::AbstractVector{T};
                        M=opEye(), N=opEye(), λ::T=zero(T), atol::T=√eps(T),
                        rtol::T=√eps(T), itmax::Int=0, verbose::Int=0) where T &lt;: AbstractFloat</code></pre><p>Solve the consistent linear system</p><pre><code class="language-none">Ax + √λs = b</code></pre><p>using the CRAIG-MR method, where λ ≥ 0 is a regularization parameter. This method is equivalent to applying the Conjugate Residuals method to the normal equations of the second kind</p><pre><code class="language-none">(AAᵀ + λI) y = b</code></pre><p>but is more stable. When λ = 0, this method solves the minimum-norm problem</p><pre><code class="language-none">min ‖x‖₂  s.t.  x ∈ argmin ‖Ax - b‖₂.</code></pre><p>When λ &gt; 0, this method solves the problem</p><pre><code class="language-none">min ‖(x,s)‖₂  s.t. Ax + √λs = b.</code></pre><p>Preconditioners M⁻¹ and N⁻¹ may be provided in the form of linear operators and are assumed to be symmetric and positive definite. Afterward CRAIGMR solves the symmetric and quasi-definite system</p><pre><code class="language-none">[ -N   Aᵀ ] [ x ]   [ 0 ]
[  A   M  ] [ y ] = [ b ],</code></pre><p>which is equivalent to applying MINRES to (M + AN⁻¹Aᵀ)y = b.</p><p>CRAIGMR produces monotonic residuals ‖r‖₂. It is formally equivalent to CRMR, though can be slightly more accurate, and intricate to implement. Both the x- and y-parts of the solution are returned.</p><p><strong>References</strong></p><ul><li>D. Orban and M. Arioli. <em>Iterative Solution of Symmetric Quasi-Definite Linear Systems</em>, Volume 3 of Spotlights. SIAM, Philadelphia, PA, 2017.</li><li>D. Orban, <em>The Projected Golub-Kahan Process for Constrained, Linear Least-Squares Problems</em>. Cahier du GERAD G-2014-15, 2014.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/c317079b058cb52fe8edb5d480a5fb25b75cfe71/src/craigmr.jl#L30-L71">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API</a><a class="docs-footer-nextpage" href="../gpu/">GPU »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 12 March 2021 15:16">Friday 12 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
